package com.varna.automationengine.application.usecase;

import org.springframework.web.multipart.MultipartFile;

/**
 * Use case interface for generating a REST Assured automation project
 * from an uploaded OpenAPI specification file.
 *
 * <p><b>What is a "use case" in clean architecture?</b><br>
 * A use case represents a single, well-defined action the system can perform
 * for a user. It lives in the {@code application} layer — the layer that
 * orchestrates the flow of data between the outer world (HTTP, files) and
 * the inner domain (business logic, generation strategies).
 *
 * <p>Think of it this way:
 * <pre>
 *   HTTP Request
 *       ↓
 *   Controller          ← "receive and validate the HTTP request"
 *       ↓
 *   UseCase (this)      ← "orchestrate the business workflow"
 *       ↓
 *   Parser / Generator  ← "do the actual technical work"
 *       ↓
 *   byte[] ZIP          ← returned back up through the same chain
 * </pre>
 *
 * <p><b>Why is this an interface?</b><br>
 * Defining this as an interface (rather than a concrete class) is a core
 * clean architecture principle called the <em>Dependency Inversion Principle</em>
 * (the "D" in SOLID):
 * <ul>
 *   <li>The {@code Controller} depends on this interface, NOT on the concrete
 *       {@code GenerateAutomationProjectService} class.</li>
 *   <li>This means you can swap the implementation (e.g. for testing) without
 *       touching the controller at all.</li>
 *   <li>In unit tests, you can pass a mock or fake implementation of this
 *       interface to the controller — no real parsing or generation needed.</li>
 * </ul>
 *
 * <p><b>Architecture note:</b><br>
 * This interface belongs to the {@code application} layer. It may reference
 * Spring types (like {@link MultipartFile}) because the application layer is
 * allowed to know about the framework. However, it must NEVER import or
 * reference infrastructure classes (parsers, template engines, zip libraries).
 */
public interface GenerateAutomationProjectUseCase {

    /**
     * Executes the full project generation pipeline for the given OpenAPI contract.
     *
     * <p>This method coordinates three stages in sequence:
     * <ol>
     *   <li><b>Parse</b> — reads the uploaded file and converts it into an internal
     *       domain model ({@code ApiContract}) that the rest of the system understands</li>
     *   <li><b>Generate</b> — uses the parsed contract to produce all source files
     *       for the REST Assured test project (test classes, POJOs, pom.xml, etc.)</li>
     *   <li><b>Package</b> — bundles all generated files into a single ZIP archive
     *       and returns the raw bytes to the caller</li>
     * </ol>
     *
     * <p><b>On exceptions:</b><br>
     * This method does not declare checked exceptions. If anything goes wrong,
     * it throws one of the domain's unchecked exceptions:
     * <ul>
     *   <li>{@code ContractParseException} — the file could not be parsed as OpenAPI</li>
     *   <li>{@code TemplateRenderException} — a code generation template failed</li>
     *   <li>{@code ProjectGenerationException} — packaging or assembly failed</li>
     * </ul>
     * All of these extend {@code AutomationEngineException} and are handled by
     * the {@code GlobalExceptionHandler} or the controller's own catch blocks.
     *
     * @param contractFile the uploaded OpenAPI specification file (.yaml, .yml, or .json);
     *                     guaranteed to be non-null and non-empty by the time this is called
     *                     (the controller validates the file before calling this method)
     * @param traceId      a unique identifier for this request, generated by the controller;
     *                     pass this through to all downstream components so every log line
     *                     for this request can be found together
     * @return the generated REST Assured project as a ZIP archive in raw bytes,
     *         ready to be written directly into an HTTP response body
     */
    byte[] execute(MultipartFile contractFile, String traceId);
}